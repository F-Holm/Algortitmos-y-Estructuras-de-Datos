Nomenclatura:

#define ALIAS texto
struct tsNom;
#typedef tvs tsNom[size]
set<tipo> cjtoT (T=1°Letra de tipo)

Entrega TPs:

- IDE: Code::Blocks
- Compilador: Borland 5.5 (solo windows)

Diccionario:

Nibble = 4b
Registro = Estructura heterogenea = struct
Estructura homogenea = Arreglo

Variables:

- short -> 2B
- int -> 4B
- long -> 4/8B (Generalmente 8)

- float -> 4B
- double -> 8B
- long double -> 10B

- char -> 1B
- bool -> 1B

Metodología para resolver problemas:

1- Comprender el problema
2- Diseñar estrategia
3- Desarrollar el algoritmo
4- Codificar el algoritmo
5- Ejecutar

Problema compuesto = 2+ problemas elementales

Algoritmo = Sucesión de pasos dados bajo un criterio lógico que tomando datos de entrada permite obtener algún resultado

Estructuras de control de programas:

- Concatenación
- Selección
- Repetición

Un módulo está formado por un conjunto de acciones que resuelven un determinado problema pero estas acciones se escriben en otro punto del algoritmo
Un módulo puede ser procedimiento / función (pascal) o función (c++) dependiendo del lenguaje

Devolver -> por Referencia
Retornar -> Return

Módulo = Función / procedimiento
Tiene 2 partes -> Header/Cabecera | cuerpo

Heap -> Donde se guardan las variables dinámicas

Valor centinela = valor especial que ... (Ej: valor de input para salir de un loop)

longitud lógica = longitud sin centinela

ANSI C++ estándar

Partes RAM:
- data
- heap -> variables dinámicas
- code
- stack

No usar continue
No tener multiples returns ni breaks

Palabras reservadas:
- son alrededor de 50
- lenguajes como pascal no distingue minusculas de mayuscula

Identificador = nombre de variable

Apostrofo: '

\0 == 0x00

"" = nulo
'' = ERROR

orden de operaciones artimeticas:

1- suma y resta como operadores unarios (-a)
2- multiplicacion, división y resultado
3- sume y resta como operador binario (a + b)

operadores relacionales:
1- operadores relacionales (==, <, >, etc,)

operadores logicos:
1- !
2- &&
3- ||

letra griega = sentencia

pseudocódigo -> i = 1

Métodos de ordenamientos:
- cuadráticos:
 + Ordenamiento Burbuja (bubble sort)
 + lentos
 + fáciles para el programador
- logarítmicos
 + rápidos
 + complejos

próx clase:
 módulo insertar en orden y matrices cuadradas - juego ',:)
módulo insertar en orden y matrices cuadradas  - (juego ',:)

matrices cuadradas:
empiezan en 1 (no en 0)

se cuenta con un archivo de gastos anuales de un año calendario
conteniendo este arhcivo los siguientes datos:

- numero de mes
- num dia
- importe
no se sabe cuantos hay
desordenado

se pide obtener un listado ordenado por mes y dentro de cada mes,
ordenado por dia, pero de importes acumulados para elementos del
mismo mes y dia

usar matriz de float 12x31

hashing = transformar/desmenuzar
en este caso se transforman las claves en direcciones/indices
para la matriz

hashing perfecto es aquel que no genera colisiones

método del resto = hashing -> hashing perfecto

Conjuntos set
#include <set>
tiene un tipo base que puede ser de cualquier tipo. Es homogeneo
Se usa #include <algorithm> para operar sobre los conjuntos/set
Se manejan con punteros

- set_union
- set_intersection
- set_difference
- set_simetric_difference

Rquieren 5 parámetros:
- ptr_inicio_1
- ptr_fin_1
- ptr_inicio_2
- ptr_fin_2
- ptr_inicio_rta

Es conveniente hacer un módulo para cada operacion de conjuntos que reciba 2 conjuntos y retorne 1
A Está incluido en B
A está incluido en B y B no está incluido en A
A = B
A != B
x pertenece a A
#A
A = cjtoVacio

Los elementos se incorporan ordenados
Se necesita de un contenedor
Es reversible
Único
Puede estar ordenado de forma ascendente o descendente
menor-mayor -> less (default, puede no ponerse)
mayor-menor -> greater
set<short,greater> cjto;
métodos
A.clear()
A.empty()
A.size()

Pascal tiene como máximo 256 elementos en setof (conjuntos/sets)

Operaciones binarias:
!  -> NOT
<< -> SHR -> desplazamientode a derecha
>> -> SHL -> desplazamientode a izquierda
&  -> AND
^  -> XOR
|  -> OR

No acepta valores repetidos
Para valores repetidos: multiset

iteratiors

set<float>::iterator it;
for (it = A.begin() ; it != A.end() ; it++){
    cout << *it << endl;
}

set<float>::reverse_iterator rit;
for (rit = A.rbegin() ; it != A.rend() ; rit++){
    cout << *rit << endl;
}

for (auto const &i: A)

template<typename T>
set<T> Union(set<T> X, set<T> Y){
    set<T> Z;
    set_union(X.begin(), X.end(), Y.begin(), Y.end(), inserter(Z, Z.begin()));
    return Z;
} // Union

Definir operators
+ Union
- Diferencia
* Intersección
/ Diferencia simétrica

template<typename T>
set<T>operato/(const set<T>&X, const set<T>&Y){
    return DiferenciaSimetrica(X, Y);
}

Unidad 4:

Archivos:
Se utilizan como almacenamiento permanente. Son archivos de memoria externa
memoria no volatil
almacenamiento masivo (mucha capacidad)
mayor timepo de acceso

Tipos de archivos:

- Maestros: se crean una sola vez y a parti de ahí se reutiliza infinitas veces.
contiene informacion vital para el desarrollo de las actividades de la organización
ABM
Un archivo debe obedecer a una misma naturaleza (no mezclar tipos)
Un registro representa a un sujeto
Pueden ser, por ejemplo, un archivo que se sobreescribe una vez al mes pasando el
contenido viejo a un backup

- Novedades/Transacciones:
pueden ser: batch o interactivo
archivos temporales
pueden ser utilizadios para actualizar un archivo maestro 
batch=recolectar los datos dentro de un período de tiempo

- Históricos: suelen ser usados con fines estadísticos

- Tablas: tienen poco volumen y pueden ser volcados directo en la memoria RAM

- Índeces: ordenado - solo contiene el valor de un campo clave, su posición (ubicación)
y, a veces, estado

- Auxiliares: Se crea y Elimina en cada ejecución

- Archivos de informes o reportes: 
S.P.O.O.L. = (Simultaneus Peripherical Operation On Line)
S.P.O.O.L. guarda las salidas de programas en wrchivos cuando el proceso que debe recibir
esa salida está ocupado

- Seguridad: backup

- Programas:

- Fuentes:

- Objetos

- I.D.E:

- Ejecutables:

- Documentos:

- Imgagen: 

- Audio: 

- Miscelánea: 

El archivo binario en más rápido porque no requiere conversión
