Nomenclatura:

#define ALIAS texto
struct tsNom;
#typedef tvsNom tsNom[size]
set<tipo> cjtoT (T=1°Letra de tipo)

Entrega TPs:

- IDE: Code::Blocks
- Compilador: Borland 5.5 (solo windows)

Diccionario:

Nibble = 4b
Registro = Estructura heterogenea = struct
Estructura homogenea = Arreglo

Variables:

- short -> 2B
- int -> 4B
- long -> 4/8B (Generalmente 8)

- float -> 4B
- double -> 8B
- long double -> 10B

- char -> 1B
- bool -> 1B

Metodología para resolver problemas:

1- Comprender el problema
2- Diseñar estrategia
3- Desarrollar el algoritmo
4- Codificar el algoritmo
- Corregir errores
5- Ejecutar
- Depurar errores

Problema compuesto = 2+ problemas elementales

Algoritmo = Sucesión de pasos dados bajo un criterio lógico que tomando datos de entrada permite obtener algún resultado

Estructuras de control de programas:

- Concatenación
- Selección
- Repetición

Un módulo está formado por un conjunto de acciones que resuelven un determinado problema pero estas acciones se escriben en otro punto del algoritmo
Un módulo puede ser procedimiento / función (pascal) o función (c++) dependiendo del lenguaje

Devolver -> por Referencia
Retornar -> Return

Módulo = Función / procedimiento
Tiene 2 partes -> Header/Cabecera | cuerpo

Heap -> Donde se guardan las variables dinámicas

Valor centinela = valor especial que ... (Ej: valor de input para salir de un loop)

longitud lógica = longitud sin centinela

ANSI C++ estándar

Partes RAM:
- data
- heap -> variables dinámicas
- code
- stack

No usar continue
No tener multiples returns ni breaks

Palabras reservadas:
- son alrededor de 50
- lenguajes como pascal no distingue minusculas de mayuscula

Identificador = nombre de variable

Apostrofo: '

\0 == 0x00

"" = nulo
'' = ERROR

orden de operaciones artimeticas:

1- suma y resta como operadores unarios (-a)
2- multiplicacion, división y resultado
3- sume y resta como operador binario (a + b)

operadores relacionales:
1- operadores relacionales (==, <, >, etc,)

operadores logicos:
1- !
2- &&
3- ||

letra griega = sentencia

pseudocódigo -> i = 1

Métodos de ordenamientos:
- cuadráticos:
 + Ordenamiento Burbuja (bubble sort)
 + lentos
 + fáciles para el programador
- logarítmicos
 + rápidos
 + complejos

próx clase:
 módulo insertar en orden y matrices cuadradas - juego ',:)
módulo insertar en orden y matrices cuadradas  - (juego ',:)

matrices cuadradas:
empiezan en 1 (no en 0)

se cuenta con un archivo de gastos anuales de un año calendario
conteniendo este arhcivo los siguientes datos:

- numero de mes
- num dia
- importe
no se sabe cuantos hay
desordenado

se pide obtener un listado ordenado por mes y dentro de cada mes,
ordenado por dia, pero de importes acumulados para elementos del
mismo mes y dia

usar matriz de float 12x31

hashing = transformar/desmenuzar
en este caso se transforman las claves en direcciones/indices
para la matriz

hashing perfecto es aquel que no genera colisiones

método del resto = hashing -> hashing perfecto

Conjuntos set
#include <set>
tiene un tipo base que puede ser de cualquier tipo. Es homogeneo
Se usa #include <algorithm> para operar sobre los conjuntos/set
Se manejan con punteros

- set_union
- set_intersection
- set_difference
- set_simetric_difference

Rquieren 5 parámetros:
- ptr_inicio_1
- ptr_fin_1
- ptr_inicio_2
- ptr_fin_2
- ptr_inicio_rta

Es conveniente hacer un módulo para cada operacion de conjuntos que reciba 2 conjuntos y retorne 1
A Está incluido en B
A está incluido en B y B no está incluido en A
A = B
A != B
x pertenece a A
#A
A = cjtoVacio

Los elementos se incorporan ordenados
Se necesita de un contenedor
Es reversible
Único
Puede estar ordenado de forma ascendente o descendente
menor-mayor -> less (default, puede no ponerse)
mayor-menor -> greater
set<short,greater> cjto;
métodos
A.clear()
A.empty()
A.size()

Pascal tiene como máximo 256 elementos en setof (conjuntos/sets)

Operaciones binarias:
!  -> NOT
<< -> SHR -> desplazamientode a derecha
>> -> SHL -> desplazamientode a izquierda
&  -> AND
^  -> XOR
|  -> OR

No acepta valores repetidos
Para valores repetidos: multiset

iteratiors

set<float>::iterator it;
for (it = A.begin() ; it != A.end() ; it++){
    cout << *it << endl;
}

set<float>::reverse_iterator rit;
for (rit = A.rbegin() ; it != A.rend() ; rit++){
    cout << *rit << endl;
}

for (auto const &i: A)

template<typename T>
set<T> Union(set<T> X, set<T> Y){
    set<T> Z;
    set_union(X.begin(), X.end(), Y.begin(), Y.end(), inserter(Z, Z.begin()));
    return Z;
} // Union

Definir operators
+ Union
- Diferencia
* Intersección
/ Diferencia simétrica

template<typename T>
set<T>operato/(const set<T>&X, const set<T>&Y){
    return DiferenciaSimetrica(X, Y);
}

Unidad 4:

Archivos:
Se utilizan como almacenamiento permanente. Son archivos de memoria externa
memoria no volatil
almacenamiento masivo (mucha capacidad)
mayor timepo de acceso

Tipos de archivos:

- Maestros: se crean una sola vez y a parti de ahí se reutiliza infinitas veces.
contiene informacion vital para el desarrollo de las actividades de la organización
ABM
Un archivo debe obedecer a una misma naturaleza (no mezclar tipos)
Un registro representa a un sujeto
Pueden ser, por ejemplo, un archivo que se sobreescribe una vez al mes pasando el
contenido viejo a un backup

- Novedades/Transacciones:
pueden ser: batch o interactivo
archivos temporales
pueden ser utilizadios para actualizar un archivo maestro 
batch=recolectar los datos dentro de un período de tiempo y subirlos todos al mismo tiempo

- Históricos: suelen ser usados con fines estadísticos

- Tablas: tienen poco volumen y pueden ser volcados directo en la memoria RAM (Ej: archivo de indices)

- Índeces: ordenado - solo contiene el valor de un campo clave, su posición (ubicación)
y, a veces, estado
Puede hacer que otro archivo esté ordenado lógicamente (porque se utiliza el archivo de indices)

- Auxiliares: Se crea y Elimina en cada ejecución

- Archivos de informes o reportes: 
S.P.O.O.L. = (Simultaneus Peripherical Operation On Line)
S.P.O.O.L. guarda las salidas de programas en archivos cuando el proceso que debe recibir
esa salida está ocupado

- Seguridad: backup

- Programas:

- Fuentes:

- Objetos

- I.D.E:

- Ejecutables:

- Documentos:

- Imgagen: 

- Audio: 

- Miscelánea: 

El archivo binario en más rápido porque no requiere conversión

Minimizar accesos a archivos por el tiempo

Enlazador=Linker
Enlazar=Link

Archivos binarios:
Se lee cada elemento de forma completa y se guardan los datos en un registro/struct
No tiene saltos de línea
Más rápido porque no hay conversión
ios::binary (modo de apertura)
.dat
i/o/fstream Arch(Nombre, ios::binary | ios::in/ios::out/ambos);
Los modos de apertura se concatenan con | (OR a nivel de bits)
Exclusivo para binario:
arch.read(char* str, sizeof(str)); -> retorna 0 si termina
arch.write(char* str, sizeof(str));

freopen solo es para archivos de texto, no sirve para archivos binarios




Modo de apertura (ios::*)
Modo de Acceso (secuencial | random)
- se utiliza una expresión artimetica para obtener la posición en el hashing

hashing perfecto -> direccionamiento directo
hashing no perfecto -> direccionamiento indirecto

en organizacion de archivos:
- secuencial
- relativa: las direcciones de los componentes se encuentran desde el
  comienzo del archivo y no desde el comienzo del disco
- indexada (y multiindexada) -> archivo y archivo de indices ordenado

C++ medio nivel

intérpretes vs compiladores
- ventajas, desventajas y definición
- interpretes te permiten ejecutar una sentencia inmediatamente sin compilar todo
- el compilador genera ejecutables más rápidos
- Python -> intérprete
- C++ -> compilador
- El intérprete traduce una sentencia a la vez
- Compilador traduce todo y luego se puede ejecutar cualquier cantidad de veces

Árbol binario:
- Raiz: primer nodo
- Hoja: otros nodos
- ?

orden (Izquierda | Raíz | Derecha)
- in  orden: I R D
- pre orden: R I D
- pos orden: I D R

Balanceado = Árbol simétrico

Cortes de control
n+1 ciclos
n = nivel de corte de control

Organización de archivos
- Secuencial
- Relativa -> Las rutas no son absolutas (son en base al inicio del archivo)
- Indexada

Hashing:

hashing perfecto -> DD (Direccionamiento directo)
hashing imperfecto -> DI (Direccionamiento indirecto)

- Caso 1: clave[1;100] & archivo[1;100] -> clave=dir -> DD
- Caso 2: clave[1001;1100] & archivo[1;100] -> f(clave)=(clave-1000)=dir -> DD
- Caso 3: clave[3795;7862] & archivo[1;100] -> f(clave)=[(clave%100)+1]=dir -> DI
- Caso 4: clave[Alfanumérica] & archivo[1;100] -> f(clave)=hash(clave)=dir -> DI
hash_imperfecto(clave)=[sumatoria(clave[k]*pk)%100 +1] ; pk = k° número primo

UNIDAD 5:

memoria contigua

punteros solo operadores == y !=
int *ptr = NULL; -> puntero nulo

punteros cercanos (NEAR): apuntan al mismo segmento (hasta 64kB)
punteros lejanos (FAR): apuntan a lugares fuera del mismo segmento (hasta 4GB (32 bits))

puntero externo:
    me permite acceder a una estructura dinámica
    Hay que inicializarlos como NULL

puntero empotrado:
    Enlaza nodos (nodo anterior o posterior)

Estructuras dinámicas de datos:
    Estructuras Lineares:
        Con restricciones:
            Pilas
            Colas
        Sin restricciones:
            Listas
    Estructuras No Lineares:
        grafos (un tipo de grafo)
        Árboles:
            Árbol Binario de Búsqueda (ABB)

Una Pila obedece a las siguientes acciones:
    Cuando se incorpora y elimina elementos por LIFO (invierte el orden)
Una Cola obedece a las siguientes acciones:
    Cuando se incorporan o eliminan elementos por FIFO

Se agregan y eliminan con push y pop

typedef short tInfo;
typedef struct sNodo* tPila;
push(pila, elemento)
pop(pila, elemento) // Si tiene un valor debe retornar el elemento
tPila pila = NULL;
while (pila) {} // pila != NULL

cada nodo ocupa 4+n Bytes (4 de puntero (32 bits) y n del dato)

struct sNodo {
    tInfo info;
    tPila ant; // anterior
};

void push(tPila& stack, tInfo valor){
    tPila pNodo = new sNodo;
    pNodo->info = valor;
    pNodo->ant = stack;
    stack = pNodo;
}

void pop(tPila& stack, tInfo& valor){
    tPila pElim = stack;
    valor = stack->info;
    stack = stack->ant;
    delete pElim;
}

pila->info
(*pila).info

colas:

enqueue(claFte, colaFin, elem); // 
dequeue(claFte, colaFin, elem); // 

short elem;
tCola colaFte = NULL;
tCola colaFin = NULL;

void Enqueue(tCola& cFte, tCola&, cFin, tInfo valor){
    tCola pNodo = new sNodo;
    pNodo->info = valor;
    pNodo->sgte = NULL;
    if(cFte == NULL)
        cFte = pNodo;
    else
        cFin->sgte = pNodo;
    cFin = pNodo;
}

void Dequeue(tCola& cFte, tCola&, cFin, tInfo& valor){
    pCola pElim = cFte;
    valor = cFte->info;
    cFte = cFte->sgte;
    if (cFte == NULL)
        cFin = NULL;
    delete pElim;
}

-- Listas --

struct sNodo{
    tipo info;
    tLista sgte;   
};

void InsertaInicio(tLista& lista, tInfo valor) { // == a push()
    sNodo nodo = new sNodo;
    nodo->info = valor;
    nodo->sgte = lista;
    lista = nodo;
}

void InsertaEnMedio(tLista& lista, tInfo valor){
    sNodo nodo = new tsNodo;
    nodo->info = valor;

    tLista aux = lista;

    while(aux->sgte != NULL && aux->sgte->info < valor) {
        aux = aux->sgte;
    }

    nodo->sgte = aux->sgte;
    aux->sgte = nodo;
}

void InsertaNodo(tLista& lista, tInfo valor){
    if (list || valor < list->info) // list <==> lista == NULL
        InsertarInicio(lista, valor);
    else
        InsertarEnMedio(lista, valor);
}

void SacarPrimerNodo(tLista& lista, tInfo& valor){
    tLista pElim = lista;
    valor = pElim->info;
    lista = lista->sgte;
    delete pElim;
}

void SuprimirNodo(tLista& lista, tipo valor) {
    tLista pAct = list;
    tLista pAnt = NULL;

    while(pAct != NULL && valor > pAct->info) {
        pAnt = pAct;
        pAct = pAct->sgte;
    }

    if (pAct != NULL && valor == pAct->info){
        if (pArt == NULL)
            lista = lista->sgte;
        else
            pAnt->sgte = pAct->sgte;
        delete pAct;
    }
}

recursividad:
+más simple a nivel decódigo
-consume más recursos (memoria y tiempo)

- lineal: factorial (fact) -> similar en uso de recursos a su forma iterativa
- múltiple: fib (fibonacci) -> no usar, usar su forma iterativa

- directa
- indirecta